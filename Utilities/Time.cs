using System.Diagnostics;

namespace Purity.Utilities
{
	/// <summary>
	/// A class that uses <see cref="System.DateTime"/> to track time and calculate time related values/timers.
	/// </summary>
	public class Time
	{
		/// <summary>
		/// The type of time convertion going from one time unit to another. This is used by <see cref="ToTime"/>.
		/// </summary>
		public enum Convertion
		{
			MillisecondsToSeconds, MillisecondsToMinutes,
			SecondsToMilliseconds, SecondsToMinutes, SecondsToHours,
			MinutesToMilliseconds, MinutesToSeconds, MinutesToHours, MinutesToDays,
			HoursToSeconds, HoursToMinutes, HoursToDays, HoursToWeeks,
			DaysToMinutes, DaysToHours, DaysToWeeks,
			WeeksToHours, WeeksToDays
		}
		[Flags]
		public enum Unit
		{
			Day = 1,
			Hour = 2,
			Minute = 4,
			Second = 8,
			Millisecond = 16,
			AM_PM = 32,
			DisplayAM_PM = 64,
		}

		/// <summary>
		/// The real time clock taken from <see cref="DateTime.Now"/> in seconds ranged
		/// [0 - 86399]<br></br>or in clock hours ranged [12 AM, 00:00, 24:00 - 11:59:59 AM, 23:59:59].
		/// </summary>
		public float Clock { get; private set; }
		/// <summary>
		/// Limits the <see cref="Delta"/> (default is 0.1 which is 10 FPS). This prevents huge values generated by long periods of not
		/// calling <see cref="Update"/> (the game lagging for a second or two or whenever the user drags the window for example).
		/// </summary>
		public float MaxDelta { get; set; } = 0.1f;
		/// <summary>
		/// The time in seconds since the last <see cref="Update"/> call. This is useful for multiplying it with a step value in continuous
		/// calculations so that the step value is consistent on all systems.<br></br><br></br>
		/// - Example: An object moving with the speed of 1 pixel per frame/tick/update in a game running at 60 <see cref="UpdatesPerSecond"/> will
		/// be moving with 60 pixels per second.<br></br> But on a game running at 120 <see cref="UpdatesPerSecond"/> - it will be moving with 120 pixels per
		/// second or twice as fast.<br></br> This also  means that some users with low-end hardware will appear to play the game in slow motion
		/// (when the <see cref="UpdatesPerSecond"/> drops bellow 40, 30, 20).<br></br>
		/// The step value of that particular object (in this case the speed of '1 pixel per frame/tick/update') should be multiplied with
		/// <see cref="Delta"/> to prevent it from messing with the gameplay.
		/// </summary>
		public float Delta { get; private set; }
		/// <summary>
		/// The amount of <see cref="Update"/> calls per second.
		/// </summary>
		public float UpdatesPerSecond { get; private set; }
		/// <summary>
		/// The average <see cref="UpdatesPerSecond"/> since the start of the application. See <see cref="UpdatesPerSecond"/> for more info.
		/// </summary>
		public float UpdatesPerSecondAverage { get; private set; }
		/// <summary>
		/// The seconds passed since the start of the application.
		/// </summary>
		public float GameClock { get; private set; }
		/// <summary>
		/// The amount of rendered frames since the start of the game.
		/// </summary>
		public uint UpdateCount { get; private set; }

		/// <summary>
		/// Updates all values and timers.
		/// </summary>
		public void Update()
		{
			var delta = (float)dt.Elapsed.TotalSeconds;
			Delta = delta.Limit(0, MathF.Max(0, MaxDelta));
			dt.Restart();

			Clock = Now;
			GameClock += Delta;
			updateFPS += Delta;
			if(updateFPS > UPDATE_FPS_EVERY_X_SEC)
			{
				updateFPS = 0;
				UpdatesPerSecond = 1f / Delta;
				UpdatesPerSecondAverage = UpdateCount / GameClock;
			}
			UpdateCount++;

			var toBeRemoved = new List<Timer>();
			for(int i = 0; i < timers.Count; i++)
			{
				var timer = timers[i];

				timer.TryTrigger(delta);

				if(timer.IsDisposed)
					toBeRemoved.Add(timer);
			}
			for(int i = 0; i < toBeRemoved.Count; i++)
			{
				var timer = toBeRemoved[i];
				timers.Remove(timer);
			}

		}

		/// <summary>
		/// Uses <see cref="System.TimeSpan"/> to convert a certain amount of <paramref name="seconds"/> into a clock/timer
		/// <see cref="string"/> with an optional <paramref name="separator"/> including multiple <paramref name="units"/>.
		/// </summary>
		public static string ConvertToClock(float seconds, string separator = ":", Unit units = Unit.Hour | Unit.Minute | Unit.Second)
		{
			var ts = TimeSpan.FromSeconds(seconds);
			var result = "";
			var counter = 0;

			if(units.HasFlag(Unit.Day))
			{
				var val = (int)ts.TotalDays;
				result += $"{val:D2}";
				counter++;
			}
			if(units.HasFlag(Unit.Hour))
			{
				var sep = counter > 0 ? separator : "";
				var val = counter == 0 ? (int)ts.TotalHours : (units.HasFlag(Unit.AM_PM) ? ts.Hours.Wrap(12) : ts.Hours);
				val = val == 0 ? 12 : val;
				result += $"{sep}{val:D2}";
				counter++;
			}
			if(units.HasFlag(Unit.Minute))
			{
				var sep = counter > 0 ? separator : "";
				var val = counter == 0 ? (int)ts.TotalMinutes : ts.Minutes;
				result += $"{sep}{val:D2}";
				counter++;
			}
			if(units.HasFlag(Unit.Second))
			{
				var sep = counter > 0 ? separator : "";
				var val = counter == 0 ? (int)ts.TotalSeconds : ts.Seconds;
				result += $"{sep}{val:D2}";
				counter++;
			}
			if(units.HasFlag(Unit.Millisecond))
			{
				var val = counter == 0 ? (int)ts.TotalMilliseconds : ts.Milliseconds;
				var dot = units.HasFlag(Unit.Second) ? "." : "";
				var sep = dot == "" && counter > 0 ? separator : "";
				result += $"{sep}{dot}{val:D3}";
				counter++;
			}
			if(units.HasFlag(Unit.DisplayAM_PM))
			{
				var sep = counter > 0 ? " " : "";
				var str = ts.Hours >= 12 ? "PM" : "AM";
				result += $"{sep}{str}";
			}
			return result;
		}
		/// <summary>
		/// Converts a <paramref name="time"/> from one time unit to another (chosen by <paramref name="convertType"/>). Then returns the result.
		/// </summary>
		public static float ConvertToTime(float time, Convertion convertType)
		{
			return convertType switch
			{
				Convertion.MillisecondsToSeconds => time / 1000,
				Convertion.MillisecondsToMinutes => time / 1000 / 60,
				Convertion.SecondsToMilliseconds => time * 1000,
				Convertion.SecondsToMinutes => time / 60,
				Convertion.SecondsToHours => time / 3600,
				Convertion.MinutesToMilliseconds => time * 60000,
				Convertion.MinutesToSeconds => time * 60,
				Convertion.MinutesToHours => time / 60,
				Convertion.MinutesToDays => time / 1440,
				Convertion.HoursToSeconds => time * 3600,
				Convertion.HoursToMinutes => time * 60,
				Convertion.HoursToDays => time / 24,
				Convertion.HoursToWeeks => time / 168,
				Convertion.DaysToMinutes => time * 1440,
				Convertion.DaysToHours => time * 24,
				Convertion.DaysToWeeks => time / 7,
				Convertion.WeeksToHours => time * 168,
				Convertion.WeeksToDays => time * 7,
				_ => 0,
			};
		}

		/// <summary>
		/// Schedules a call to a provided <paramref name="method"/> after a certain amount of <paramref name="seconds"/>.
		/// May also call it continuously every few <paramref name="seconds"/> if it <paramref name="isRepeating"/>. In other words:
		/// subscribe a <paramref name="method"/> to a timer.
		/// </summary>
		public static void CallAfter(float seconds, Action method, bool isRepeating = false)
		{
			timers.Add(new Timer(seconds, isRepeating, method));
		}
		/// <summary>
		/// Cancel any scheduled calls to a certain <paramref name="method"/>. In other words: unsubscribe a method from a timer.
		/// </summary>
		public static void CancelCall(Action method)
		{
			var timersToRemove = new List<Timer>();
			for(int i = 0; i < timers.Count; i++)
				if(timers[i].method == method)
					timersToRemove.Add(timers[i]);

			for(int i = 0; i < timersToRemove.Count; i++)
				timers.Remove(timersToRemove[i]);
		}
		/// <summary>
		/// Offset the call time of a scheduled <paramref name="method"/> by a certain <paramref name="secondsOffset"/>.
		/// </summary>
		public static void OffsetCall(float secondsOffset, Action method)
		{
			for(int i = 0; i < timers.Count; i++)
				if(timers[i].method == method)
					timers[i].delay += secondsOffset;
		}

		#region Backend
		private class Timer
		{
			public Action? method;
			public float time;
			public bool isLooping;
			public float delay;
			public bool IsDisposed => method == null;

			public Timer(float seconds, bool isLooping, Action method)
			{
				delay = seconds;
				this.isLooping = isLooping;
				this.method = method;
			}

			public void TryTrigger(float delta)
			{
				time += delta;

				if(time < delay)
					return;

				Trigger(true);

				if(isLooping == false)
					Dispose();
			}
			public void Restart()
			{
				time = 0;
			}
			public void Trigger(bool reset)
			{
				method?.Invoke();

				if(reset)
					Restart();
			}

			private void Dispose()
			{
				method = null;
			}
		}

		private static readonly List<Timer> timers = new();
		private float updateFPS;
		private readonly Stopwatch dt = new();
		private const float UPDATE_FPS_EVERY_X_SEC = 0.1f;

		private static float Now => (float)DateTime.Now.TimeOfDay.TotalSeconds;
		#endregion
	}
}
